# 브랜치 규칙
- feat/~~ : 새 기능 추가
- fix/~~ : 오류 수정
- hotfix/~~ : 급한 오류 수정
- docs/~~ : 문서
- ex) feat/add_bakery_favorite

---

# 개발 관련

- 한 달 이내에 기말고사와 다른 과제를 병행하며 39개의 기능을 모두 구현하는 것은 현실적으로 매우 어렵다.
- 기능은 크게 '빵집(가게)' 중심 기능과 '빵지순례 코스' 중심 기능으로 나뉜다.
- 가장 핵심적인 기능에 집중하고 나머지는 우선순위를 낮추는 전략이 필요함.

---

## 🚀 개발 우선순위

개발 순서는 의존성이 높은 기능부터 처리하는 것이 기본. 예를 들어, 리뷰(11)를 쓰려면 가게(7)가 먼저 보이고, 가게를 보려면 로그인(2)이 되어야 하는 식.

기능을 크게 5단계로 나누어 정한 순서이다.

### 1순위: 시스템의 뼈대 (회원 인증 & 핵심 조회)

가장 기본이 되는 기능입니다. 이게 없으면 아무것도 할 수 없습니다.

* (1) 회원 가입하기
* (2) 로그인하기
* (3) 로그아웃하기
* (7) 가게 정보 보기 (+ (14) 가게 메뉴 목록 보기 포함)
* (5) 가게 검색하기
* (10) 가게 리뷰 보기

> [Back/Front 병렬 작업 Tip]
> 백엔드는 (1), (2), (3) API를 먼저 개발하고, 프론트엔드는 (5), (7), (10)의 UI를 **더미 데이터(Mock data)**로 먼저 만듭니다. 백엔드의 가게/리뷰 API가 완성되면 프론트에서 데이터를 연동합니다.

### 2순위: 핵심 상호작용 (가게 리뷰 CRUD)

사용자가 앱을 사용하는 주된 이유입니다. '조회' 기능이 완성된 후 바로 '생성/수정/삭제' 기능을 구현합니다.

* (11) 가게 리뷰 쓰기
* (12) 가게 리뷰 수정하기
* (13) 가게 리뷰 삭제하기
* (33) 닉네임 변경하기 (마이페이지의 기본 기능)

### 3순위: 사용자 편의 기능 (관심 목록 & 마이페이지)

핵심 기능이 완성된 후 사용자 경험을 높여줄 기능입니다.

* (8) 가게 관심 추가하기 (스크랩하기)
* (9) 가게 관심 삭제하기
* (34) 관심 가게 목록 보기 (마이페이지)
* (36) 내가 쓴 가게 리뷰 보기 (마이페이지)

### 4순위: 두 번째 핵심 기능 (빵지순례 코스)

시간이 허락한다면 도전할 두 번째 핵심 도메인입니다. 이것도 1~3순위와 마찬가지로 `조회 -> 생성/수정/삭제 -> 관심` 순서로 진행합니다.

* (24) 빵지순례 상세 페이지 보기
* (23) 빵지순례 검색하기
* (22) 인기 빵지순례 보기
* (30) 빵지순례 만들기
* (31) 빵지순례 수정하기
* (32) 빵지순례 삭제하기
* ...이후 코스 관련 관심/리뷰/마이페이지 기능...

### 5순위: 후순위 기능 (세부 리뷰 및 제보)

MVP(최소 기능) 범위에서는 제외해도 좋은 기능들입니다.

* (16)~(18) 메뉴 리뷰 관련 기능: 가게 리뷰만으로도 충분합니다. 메뉴별 리뷰는 매우 세분화된 기능입니다.
* (19)~(21) 제보 관련 기능: 관리자 기능이 없다면 제보를 받아도 처리하기 어렵습니다.
* (4) 회원 탈퇴하기: 중요하지만, 회원 가입/로그인보다 급하지 않습니다.

---

## 🎯 최소 기능 범위 (MVP) 정의

학업과 병행하는 **한 달 프로젝트**라면 **'빵집'이라는 첫 번째 핵심 축을 완성**하는 것을 목표로 삼는 것이 가장 현실적이고 현명합니다.

**"사용자가 빵집을 검색하고, 상세 정보를 확인하며, 리뷰를 남기고, 관심 목록에 추가할 수 있다."**

이것을 MVP로 정의하고, 아래 기능들(1~3순위)을 **'필수 완성 기능'**으로 설정하세요.

### 📍 MVP 필수 기능 목록 (총 13개)

1.  **(1) 회원 가입하기**
2.  **(2) 로그인하기**
3.  **(3) 로그아웃하기**
4.  **(5) 가게 검색하기**
5.  **(7) 가게 정보 보기 (메뉴 목록 포함)**
6.  **(10) 가게 리뷰 보기**
7.  **(11) 가게 리뷰 쓰기**
8.  **(12) 가게 리뷰 수정하기**
9.  **(13) 가게 리뷰 삭제하기**
10. **(8) 가게 관심 추가하기**
11. **(9) 가게 관심 삭제하기**
12. **(34) 관심 가게 목록 보기**
13. **(36) 내가 쓴 가게 리뷰 보기**

---

## 💡 Spring/React 팀을 위한 핵심 조언

백엔드와 프론트엔드가 나뉘어 작업할 때 가장 중요한 것은 **'API 명세(Contract)'**입니다.

1.  **DTO와 API Endpoint부터 확정하세요.**
    * 백엔드가 코딩을 시작하기 전에, 프론트엔드와 합의하여 위 MVP 기능들에 대한 **Request/Response DTO**와 **API URL(Endpoint)**을 `Swagger`나 `Notion` 등에 먼저 문서화하세요.
    * 예: `POST /api/v1/auth/signup` (Request DTO: `SignupRequest.java`, Response DTO: `MemberResponse.java`)
2.  **병렬로 작업하세요.**
    * **백엔드 팀:** 합의된 명세대로 API를 개발하고 Postman 등으로 테스트합니다.
    * **프론트엔드 팀:** 백엔드 API가 완성될 때까지 기다리지 말고, 합의된 **DTO 명세와 똑같은 Mock Data(가짜 데이터)**를 만들어 UI 컴포넌트 개발을 완료합니다.
3.  **연동 및 테스트 (통합)**
    * 백엔드 API 개발이 완료되면, 프론트엔드는 Mock Data를 실제 API 호출로 교체하며 연동 작업을 진행합니다.

이 순서로 진행하면 서로 기다리는 시간 없이 한 달 내에 MVP 완성이 충분히 가능할 것입니다.

혹시 MVP 기능들에 대한 API 명세를 잡는 데 도움이 필요하면 다시 요청해 주세요!

---

# 구체적 구현 일정

제시해주신 우선순위를 바탕으로 3:3 팀 구성에 최적화된 4주 개발 일정(로드맵)을 짜봤습니다. 기말고사 기간을 고려하여 4주차는 버퍼 기간 및 선택적 기능 개발로 남겨두는 것이 현실적입니다.

핵심은 **'API 명세(설계) 선행'**과 **'BE/FE 병렬 개발'**입니다.

---

## 📅 4주 완성 개발 로드맵 (FE: 3명, BE: 3명)

**[김서현]** DTO 및 API 관련 담당

### 1주차: 뼈대 구축 및 핵심 조회 (P1)

* **공통 목표:** 프로젝트 환경 설정, API 명세 확정, 핵심 조회 기능(Read) UI/API 개발
* **[Back-End (3명)]**
    * **(필수) DB 변경:** H2 -> **MariaDB**로 변경 및 Spring 연결 (이전 조언 참고)
    * **(필수) API 명세 작성 (P1, P2):** 1, 2순위 기능(회원가입~리뷰쓰기)에 대한 API 명세(`Swagger` 또는 `Notion`)를 프론트와 **미리 확정**합니다.
    * **[김서연]** Spring Security 설정, 회원가입/로그인/로그아웃 API 개발 (P1: 1, 2, 3)
    * **[박세은]** 가게 검색/가게 정보 보기/가게 메뉴 목록 보기/가게 리뷰 보기 API 개발 (P1: 5, 7, 10, 14)
    * **[김서현]** 배포용 DB 구성. 컨트롤러에 api 매핑. 초기 데이터(`data.sql`). PR 템플릿 삽입
* **[Front-End (3명)]**
    * **(필수) API 명세 검토:** 백엔드와 P1, P2 명세를 함께 검토하고 확정합니다.
    * **(필수) Mock Data 생성:** 확정된 API 명세를 기반으로 가짜 데이터(JSON)를 만듭니다.
    * **[담당 1]** 회원가입/로그인 페이지 UI 개발 (P1: 1, 2)
    * **[담당 2]** 메인 (가게 검색), 가게 상세정보/메뉴 UI 개발 (P1: 5, 7, 14) - *Mock Data 사용*
    * **[담당 3]** 가게 리뷰 목록 UI 개발 (P1: 10), 공통 레이아웃(헤더/푸터) 개발

### 2주차: 핵심 기능 연동 및 CRUD (P1 + P2)

* **공통 목표:** 1주차에 만든 UI와 API를 연동하고, 핵심 상호작용(리뷰 CRUD) 기능을 구현합니다.
* **[Back-End (3명)]**
    * **(필수) 1차 배포:** 백엔드 서버를 **Render.com** 등에 1차 배포합니다. (CORS 설정 포함)
    * **[담당 1]** 1주차 기능(Auth) 프론트 연동 지원 및 버그 수정
    * **[담당 2]** 가게 리뷰 CRUD API 개발 (P2: 11, 12, 13)
    * **[담당 3]** 닉네임 변경 API 개발 (P2: 33), P3 API(가게 관심) 개발 시작
* **[Front-End (3명)]**
    * **(필수) 1차 배포:** 프론트 서버를 **Vercel/Netlify** 등에 1차 배포합니다.
    * **[담당 1]** 회원가입/로그인 페이지 API 연동 (P1: 1, 2, 3) - *Axios, 토큰 관리 설정*
    * **[담당 2]** 가게 검색/상세/메뉴 페이지 API 연동 (P1: 5, 7, 10, 14) - *Mock Data -> 실제 API*
    * **[담당 3]** 리뷰 작성/수정/삭제 UI 및 API 연동 (P2: 11, 12, 13), 닉네임 변경 UI 개발 (P2: 33)

### 3주차: MVP 완성 및 마이페이지 (P3)

* **공통 목표:** MVP(1~3순위) 기능을 완성하고, 마이페이지를 구현하여 '사용자 경험'을 완성합니다.
* **[Back-End (3명)]**
    * **[담당 1]** 가게 관심 추가/삭제 API 개발 (P3: 8, 9)
    * **[담당 2]** 마이페이지 - 관심 가게 목록 보기 API (P3: 34)
    * **[담당 3]** 마이페이지 - 내가 쓴 가게 리뷰 보기 API (P3: 36)
    * *(공통)* P1, P2 기능 버그 수정 및 안정화
* **[Front-End (3명)]**
    * **[담당 1]** 가게 상세 페이지에 '관심 추가/삭제' 버튼 UI 및 API 연동 (P3: 8, 9)
    * **[담당 2]** 마이페이지 - 관심 가게 목록 페이지 UI 및 API 연동 (P3: 34)
    * **[담당 3]** 마이페이지 - 내가 쓴 리뷰 목록 UI 및 API 연동 (P3: 36), 닉네임 변경 API 연동 (P2: 33)
    * *(공통)* 전체적인 CSS 다듬기 및 반응형 디자인 점검

### 4주차: 버퍼, 빵지순례(P4) 또는 MVP 고도화

* **공통 목표:** (선택 1) MVP(P1~P3)의 버그를 잡고 발표 준비 / (선택 2) 시간이 남으면 빵지순례(P4) 기능 개발
* **[Back-End (3명)]**
    * **(선택 1 - 안정화):** P1~P3 기능에서 발생한 버그 수정, 예외 처리 보강, `README.md` 작성
    * **(선택 2 - P4 개발):** 3명이 각자 `빵지순례 조회 (24, 23)`, `빵지순례 CRUD (30, 31, 32)`, `빵지순례 리뷰/관심 (25~29)` API를 나눠서 개발합니다.
* **[Front-End (3명)]**
    * **(선택 1 - 안정화):** P1~P3 기능 UI/UX 개선, 로딩/에러 화면 처리, 발표 자료 준비
    * **(선택 2 - P4 개발):** 3명이 각자 `빵지순례 조회 UI`, `빵지순례 CRUD UI` 등을 나눠서 개발하고 API를 연동합니다.

> **💡 현실적인 조언**
> 기말고사를 고려하면 **4주차는 (선택 1 - 안정화)**에 집중하는 것이 좋습니다.
> '빵지순례(P4)'는 "기획과 설계(시퀀스 다이어그램)는 완료했으나, MVP 완성을 위해 개발 우선순위에서 조절했다"고 발표하는 것이 '만들다 만' 것보다 훨씬 프로페셔널합니다.


---


# DB 데이터 입력 관련

현실적인 난이도와 한 달 이내의 개발 기간을 고려할 때, 결론부터 말씀드리면 **DB에 직접 데이터를 넣는 것**이 훨씬 좋다.

### 2\. 직접 DB에 데이터 입력 (수동)

MVP(최소 기능 제품)를 빠르게 완성하고 프로젝트의 핵심 로직에 집중하는 데 가장 유리한 방식입니다.

* **낮은 난이도:**
    * API 연동에 비해 기술적 난이도가 **0**에 가깝습니다.
    * 우리 팀이 정의한 `Bakery` 엔티티 구조에 딱 맞는 '깨끗한' 데이터를 넣을 수 있습니다.
* **빠른 개발:**
    * 데이터가 이미 준비되어 있으므로, 프론트엔드와 백엔드 모두 '가게 조회', '리뷰 작성' 등 핵심 기능 개발에 바로 집중할 수 있습니다.
* **단점 (하지만 괜찮음):**
    * 데이터 수집이 다소 번거롭습니다. (소위 '노가다')
    * 하지만 프로젝트 시연을 위해 20\~30개 정도의 데이터만 있으면 충분합니다.

-----

## 🎯 현실적인 데이터 확보 전략 (추천)

**"Spring Boot의 `data.sql` 파일을 이용해 초기 데이터를 자동으로 삽입하세요."**

이 방법이 가장 간단하고 효율적입니다.

**방법:**

1.  팀원들과 함께 구글 시트 같은 곳에 시연에 필요한 빵집 20개 정도의 정보를 수집합니다. (가게 이름, 주소, 간단한 설명, 위도/경도 등)
2.  이 정보를 바탕으로 `INSERT` 쿼리를 만듭니다.
3.  Spring Boot 프로젝트의 `src/main/resources/` 폴더 안에 **`data.sql`** 파일을 만듭니다.
4.  이 파일 안에 `INSERT` 쿼리를 넣어둡니다.

**예시 `data.sql`:**

```sql
-- 빵집 데이터
INSERT INTO bakery (name, address, description, latitude, longitude) 
VALUES ('성심당', '대전광역시 중구 대종로 480', '대전의 명물 빵집입니다.', 36.3275, 127.4270);

INSERT INTO bakery (name, address, description, latitude, longitude) 
VALUES ('나폴레옹 과자점', '서울특별시 성북구 성북로 7', '사라다빵이 유명합니다.', 37.5923, 126.9899);

-- 메뉴 데이터 (가게 데이터가 먼저 삽입되어야 함)
-- (주의: bakery_id는 실제 삽입된 빵집의 ID를 확인하고 맞춰야 합니다. 보통 1, 2... 순서)
INSERT INTO menu (bakery_id, name, price) 
VALUES (1, '튀김소보로', 1700);

INSERT INTO menu (bakery_id, name, price) 
VALUES (1, '판타롱부추빵', 2000);

INSERT INTO menu (bakery_id, name, price) 
VALUES (2, '사라다빵', 8500);
```

**이렇게 하면 좋은 점:**

* `application.yml` (또는 `properties`)에서 `spring.jpa.hibernate.ddl-auto`가 `create` 또는 `create-drop`으로 되어 있으면, **애플리케이션이 실행될 때마다 `data.sql`이 자동으로 실행되어 DB에 데이터를 넣어줍니다.**
* 개발 중에 DB가 초기화되어도 앱 실행 한 번으로 데이터가 복구됩니다.
* 팀원 모두가 동일한 초기 데이터를 공유하며 개발할 수 있습니다.

혹시 `data.sql`을 설정하는 방법이나 초기 데이터에 어떤 항목을 넣는 게 좋을지 더 자세한 도움이 필요하면 알려주세요\!

---

# 배포 관련

### 1\. 🎯 결론: H2 vs MariaDB

**지금이라도 당장 MariaDB (혹은 MySQL)로 바꾸는 것이 맞습니다.**

* **H2의 문제점 (인메모리 DB):** H2는 애플리케이션(서버)을 껐다 켜면 **모든 데이터가 사라집니다.**
* **제출 요구사항:** "12월 25일까지 서버를 열어두기"
* **문제 상황:** 교수님이나 평가자가 접속해서 회원가입을 하고 리뷰를 썼는데, 팀에서 서버를 업데이트하거나 재시작하면 그 데이터가 모두 사라집니다. 이건 평가가 불가능한 수준입니다.

따라서 데이터가 영구적으로 저장되는 **MariaDB, MySQL, PostgreSQL** 같은 실제 데이터베이스를 사용해야 합니다.

### 2\. 🚀 '서버 열기' (배포) 간단 로드맵 (학생용 무료/최저 플랜)

'배포 파일을 실행 환경에 올리고 서버를 연다'는 것은, \*\*"팀원들 컴퓨터가 꺼져 있어도 24시간 내내 누구나 접속할 수 있는 공개 링크를 만든다"\*\*는 뜻입니다.

React(프론트)와 Spring Boot(백엔드)는 따로 배포하는 것이 가장 쉽고 표준적인 방법입니다.

-----

#### 1단계: 데이터베이스(DB) 분리하기 (MariaDB)

서버(Spring)와 DB를 한곳에 설치하면 복잡하니, DB만 전문적으로 빌려주는 서비스를 씁니다.

1.  **DB 호스팅 받기 (추천: AWS RDS)**
    * [AWS(Amazon Web Services)](https://aws.amazon.com/)에 가입하고, \*\*RDS(Relational Database Service)\*\*라는 서비스로 갑니다.
    * 거기서 **MariaDB** (혹은 MySQL) 데이터베이스를 \*\*'프리 티어(Free Tier)'\*\*로 생성합니다.
    * 생성이 완료되면 DB에 접속할 수 있는 **'엔드포인트(Endpoint) 주소'** (일종의 URL), DB 이름, 마스터 ID, 비밀번호를 줍니다.
2.  **Spring Boot에 연결하기**
    * Spring Boot 프로젝트의 `application.yml` (또는 `properties`) 파일에 있는 H2 설정(`spring.datasource.url=jdbc:h2:mem:testdb`)을 **지우고**, AWS에서 받은 MariaDB 접속 정보로 변경합니다.

**예시 `application.yml`:**

```yaml
spring:
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://[AWS에서-받은-엔드포인트-주소]:3306/[DB-이름]
    username: [AWS에서-설정한-ID]
    password: [AWS에서-설정한-비밀번호]
  jpa:
    hibernate:
      ddl-auto: update # (중요) update나 none으로 설정 (create-drop 절대 금지)
```

-----

#### 2단계: 백엔드(Spring Boot) 배포하기

Spring Boot 프로젝트를 빌드하면 나오는 **`...-SNAPSHOT.jar`** 파일이 교수님이 말한 "실행가능한 배포 파일"입니다. 이 `jar` 파일을 24시간 돌려줄 서버가 필요합니다.

* **추천 서비스: Render.com (무료 플랜)**
    1.  [Render](https://render.com/) 가입 후 'New+' -\> 'Web Service'를 선택합니다.
    2.  팀의 GitHub 리포지토리를 연결합니다.
    3.  **Language:** `Java`
    4.  **Build Command:** `build.gradle`을 쓴다면 `./gradlew build`
    5.  **Start Command:** `java -jar build/libs/프로젝트명-0.0.1-SNAPSHOT.jar`
    6.  **'Free'** 플랜을 선택합니다.
    7.  **(매우 중요) 'Environment' (환경 변수) 설정**에서 1단계의 DB 접속 정보(`spring.datasource.url`, `username`, `password`)를 등록해 줍니다. (보안을 위해 yml 파일이 아닌 환경 변수로 주입)

Render가 알아서 GitHub 코드를 가져가 빌드하고 서버를 실행시켜 줍니다. 완료되면 `https://팀프로젝트.onrender.com` 같은 **백엔드 서버 링크**가 생깁니다.

-----

#### 3단계: 프론트엔드(React) 배포하기

React 프로젝트는 `npm run build`를 실행하면 생기는 `build` 폴더 (정적 파일)가 "배포 파일"입니다.

* **추천 서비스: Vercel 또는 Netlify (무료 플랜)**
    1.  [Vercel](https://vercel.com/) (혹은 Netlify)에 가입하고 'Add New...' -\> 'Project'를 선택합니다.
    2.  프론트엔드 GitHub 리포지토리를 연결합니다.
    3.  프레임워크가 `React`인 것을 자동으로 감지합니다. 그냥 'Deploy' 버튼만 누르면 됩니다.
    4.  배포가 완료되면 `https://팀프로젝트.vercel.app` 같은 **최종 링크**가 생깁니다.

-----

#### 4단계: (필수\!) 프론트-백엔드 연결 및 CORS 해결

이제 마지막으로 2단계와 3단계를 연결해야 합니다.

1.  **React 코드 수정:**
    * React에서 `axios`나 `fetch`로 API를 요청하는 부분의 주소를 `http://localhost:8080`이 아니라, 2단계에서 만든 **백엔드 서버 링크**(`https://팀프로젝트.onrender.com`)로 모두 변경하고 Vercel에 다시 배포합니다.
2.  **Spring Boot CORS 설정:**
    * React 서버(`vercel.app`)가 백엔드 서버(`onrender.com`)에 요청하면 100% **CORS 오류**가 발생합니다.
    * Spring Boot에 `WebConfig` 같은 설정 파일을 만들어서 Vercel에서 오는 요청을 허용해 줘야 합니다.

**예시 `WebConfig.java`:**

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**") // API 경로 패턴
                .allowedOrigins("https://팀프로젝트.vercel.app") // 3단계에서 만든 React 링크
                .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

이 4단계를 완료하면 교수님께 **Vercel 링크(3단계) 하나만 제출**하면 됩니다. 그 링크가 "실행가능한 링크"이며, 12월 25일까지 서버가 열려있게 됩니다.

지금 H2를 MariaDB(RDS)로 바꾸는 작업부터 바로 시작하세요\!